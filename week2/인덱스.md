# 인덱스를 Range Scan 할 수 없는 이유

책에는 다음과 같은 문장이 등장합니다.

> 인덱스를 가공하면 인덱스를 정상적으로 사용(Range Scan) 할 수 없다.

왜 인덱스를 가공하면 찾지 못하는 걸까요? 이에 답하기 위해 먼저 인덱스가 뭔지 부터 알아보겠습니다.

## 인덱스

데이터베이스를 학습하다보면 `인덱스(index)`라는 용어를 많이 접하게 되는데요. 인덱스란 무엇일까요?

인덱스를 흔히 책의 맨 끝에 있는 색인에 비유하고는 합니다. 책의 끝을 보면 용어들이 나열되어 있고 해당 용어가 몇 페이지에 나와있는지 나열되어 있습니다. 또한 '가나다' 순으로 정렬되어 있는 것도 확인할 수 있습니다. 이처럼 인덱스도 데이터들을 정렬된 상태로 별도의 공간에 보관합니다. (그렇기 때문에 추가적인 공간도 필요합니다.)<br>
이러한 특징 때문에 INSERT, UPDATE, DELETE 연산 시 정렬을 유지하기 위한 추가 연산이 필요하며 이에 따른 오버헤드가 발생합니다.

인덱스의 또 다른 특징으로는 인덱스는 B-Tree 계열의 자료구조, 혹은 Hash 자료구조를 이용한다는 특징이 있습니다.

### B-Tree 인덱스

B-Tree는 데이터베이스의 인덱싱 자료구조 중 가장 일반적으로 사용되는 자료구조입니다. B-Tree에는 여러 변형이 존재하는데 B+-Tree, B\*-Tree가 존재합니다.

> `B`는 `Binary`가 아닌 `Balanced`입니다.

B-Tree는 Balanced Tree의 일종으로 최상위에 하나의 루트 노드(Root node)가 존재하며 하위에 자식 노드들이 붙어 있는 형태입니다. 트리 구조에서 가장 하위에 있는 노드를 리프 노드(Leaf node)라고 하며 루트 노드도 리프 노드도 아닌 노드를 브랜치 노드(Branch node)라고 합니다.

![image](https://github.com/masters2023-project-03-second-hand/second-hand-max-be-b/assets/66981851/e29e3b80-04e5-4235-aaa0-69dad9384704)

위 그림과 같이 한 노드에 2개, 3개.. 의 데이터가 들어갈 수 있으며 항상 정렬된 상태를 유지합니다. 그리고 왼쪽 서브트리는 특정 노드의 key 값보다 작은 값들로, 오른쪽 서브트리는 특정 노드의 key 값보다 큰 값들로 구성된다는 특징이 있습니다.

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하게 되는데, 그렇기 때문에 인덱스의 리프 노드는 실제 데이터가 저장된 주솟값을 가지고 있습니다.

> MySQL InnoDB 엔진에서는 세컨더리 인덱스의 경우, 리프 노드가 프라이머리 키의 주소를 가리키고 있어 논리적인 주소를 가지고 있다고 볼 수 있습니다. 그렇기 때문에 InnoDB에서 세컨더리 인덱스를 통해 데이터를 읽게 되면 프라이머리 키 인덱스를 한 번 더 검색하게 됩니다.

### B+-Tree

B+-Tree는 자식 노드가 두 개 이상인 B-Tree를 개선시킨 자료구조입니다. B-Tree는 모든 노드에 데이터를 저장했다면 B+-Tree는 리프 노드에만 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 키 값을 가지게 됩니다.<br>
또 다른 특징은 리프 노드들은 LinkedList로 연결되어 있습니다. 따라서 일점 범위의 연속된 데이터의 탐색이 용이합니다.

### Hash 인덱스

Hash Index는 해시 테이블을 이용해 데이터를 저장하는 자료구조 입니다. 그렇기 때문에 특정 key값으로 해시 연산을 수행해 고유한 index를 생성하고 그 index에 저장된 값을 가져오는 구조입니다. 해시 테이블의 시간복잡도는 O(1)이기 때문에 매우 빠른 검색을 지원합니다.

> Hash Index? B-Tree Index? 🧐 <br>
> 그렇다면 Hash index가 더 빠른 것 같은데 왜 B-Tree 인덱스를 많이 사용할까요? 이유는 범위 탐색에 있습니다. 부등호 연산(>, <)이 수행되는 경우 부등호 내에 있는 모든 키값으로 해시 연산을 수행해야하기 때문에 인덱스의 혜택을 전혀 못받게 됩니다. 그렇기 때문에 데이터베이스에서는 B-Tree계열의 인덱스를 사용하는 것입니다.

## 인덱스 튜닝

위에서 살펴봤듯이 인덱스는 어떤 데이터를 효율적으로 찾기 위해 사용되는 기술입니다. 이 인덱스를 적절히 사용해 튜닝하는데 두 가지 핵심요소가 존재합니다.

1. 인덱스 스캔 과정에서 발생하는 비효율을 줄이기
2. 테이블 액세스 횟수 줄이기

다음과 같은 학생 명부가 있다고 해보겠습니다.

|  이름  | 시력 |  학년-반-번호  |
| :----: | :--: | :------------: |
| 강수지 | 1.1  | 4학년 8반 23번 |
| 김철수 | 1.3  | 3학년 2반 15번 |
| 박영희 | 0.1  | 5학년 1반 02번 |
| 박철수 | 0.5  | 6학년 4반 18번 |
| 이용식 | 1.5  | 1학년 6반 24번 |
| 홍길동 | 1.4  | 2학년 2반 11번 |
| 홍길동 | 1.5  | 5학년 3반 04번 |
| 홍길동 | 2.0  | 3학년 3반 04번 |

이 학생 명부는 이름-시력순으로 정렬되어 있다고 했을 때 `홍길동`을 찾으려면 `홍길동-1.4`부터 소량만 스캔하면 됩니다. 하지만 시력-이름으로 되어 있다면 `홍길동`을 찾기 위해서 테이블 전체를 스캔해야 할 수도 있습니다. 이처럼 인덱스를 어떤 컬럼을 먼저 기준으로 정렬해야할 지에 따라 비효율을 줄일 수 있습니다.<br>

테이블 액세스 횟수를 줄이는 것은 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하기 때문에 다른 말로 `랜덤 액세스 최소화 튜닝`이라고 합니다.<br>

시력이 1.0~1.5인 학생은 50명, 홍길동 학생은 5명이라고 가정해봅시다.
학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는다고 했을 때 이름순으로 정렬된 명부, 시력순으로 정렬된 명부가 있으면 어떤 걸 사용하는게 좋을까요? 이름순으로 정렬된 명부를 사용하는 것이 좋습니다. 왜냐하면 교실을 5번만 찾아가면 되는데 시력으로 정렬된 명부를 사용하면 50번을 찾아가야 합니다.

## 인덱스 탐색

인덱스를 탐색하는 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있습니다.

- 수직적 탐색 : 인덱스 스캔의 `시작지점`을 찾는 과정
  - 정렬된 인덱스의 레코드 중에서 조건을 만족하는 첫 번쨰 레코드를 찾는 것이 수직적 탐색입니다. B-Tree 계열의 인덱스에서 루트 블럭(페이지)부터 시작해 찾고자 하는 리프 블럭(페이지)까지 탐색을 시작합니다.
- 수평적 탐색 : 데이터를 찾는 과정
  - 위 과정에서 스캔 시작점을 찾았다면 찾고자 하는 데이터가 나타나지 않을 떄까지 인덱스 리프 블럭(페이지)을 수평적으로 탐색하게 됩니다.

그러면 인덱스 컬럼을 가공하면 인덱스를 Range Scan할 수 없는 이유는 무엇일까요?

결론부터 말하자면 인덱스 스캔 시작점을 찾을 수 없기 때문입니다. 위의 예에서도 시력-이름순으로 정렬된 학생명부에서 홍길동이라는 학생을 찾으려면 어떻게 해야할까요? 어디서부터 시작하고 어디서부터 멈춰야 할까요? 스캔 시작점과 끝지점을 알 수 없어 모든 데이터를 스캔해야 합니다.
