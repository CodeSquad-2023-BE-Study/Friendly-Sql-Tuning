# InnoDB 스토리지 엔진 잠금

MySQL 엔진과 달리 InnoDB는 스토리지 엔진 내부에서 레코드 기반의 잠금을 제공합니다.
잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락 에스컬레이션 현상이 발생할 일이 없습니다.

```
🧐 락 에스컬레이션 (Lock Escalation)

많은 수의 미세 잠금을 더 작은 수의 큰 잠금으로 변환하는 작업입니다.
```

## Shared lock & Exclusive lock

InnoDB는 row-level 락을 S lock과 X lock을 통해 구현합니다.

- shared(S) lock은 트랜잭션이 어떤 행을 읽을 때 거는 잠금입니다.
- exclusive(X) lock은 트랜잭션이 어떤 행을 업데이트 혹은 삭제할 때 거는 잠금입니다.

만약 어떤 T1 트랜잭션이 S lock을 쥐고 있다면, 다른 트랜잭션 T2는 다음을 따릅니다.

- T2가 S lock을 획득하는 것을 허용합니다.
- T2가 X lock을 획득하는 것은 금지합니다.

만약 T1이 X lock을 쥐고 있다면, 다른 트랜잭션 T2에 대하여 어떠한 락을 획득하는 것도 허용하지 않습니다.

## Intention lock

### Multiple Granularity Locking (MGL)

Intention lock을 설명하기 전 먼저 Multiple Granularity Locking (MGL)에 대해 설명하고자 합니다.
MGL은 락의 단위를 다르게 가져가는 기법입니다. 데이터베이스는 크게 DB, Table 작게는 record 단위로 락을 획득하고 놓을 수 있게 합니다.

- Fine Granularity
  - 레코드 단위로 락을 잘게 쪼개어 관리
  - 동시성 향상, 락 오버헤드 증가
- Coarse Granularity
  - 테이블처럼 큰 단위로 락을 관리
  - 동시성 하락, 락 오버헤드 감소
- Multiple Granularity
  - Fine, Coarse를 적절히 섞어 사용하는 방법

Multiple Granulity는 데이터베이스를 계층적으로 잠글 수 있는 블럭으로 나눕니다.(잠글 필요가 있는 것이 무엇이며 어떤 방식으로 잠글지 추적할 수 있는 블럭으로 나눈다는 것을 의미)<br>
이러한 계층을 트리로 표현할 수 있습니다.

예를 들어 4개의 레벨로 구성된 트리를 생각해보겠습니다.
가장 높은 레벨은 데이터베이스를 의미합니다. <br>
아래에는 Area 타입의 노드가 존재합니다.
<br> 이 area에는 파일이라고 불리는 자식 노드가 존재합니다. 그리고 모든 영역에는 자식 노드인 파일이 존재합니다. 어떤 파일도 하나 이상의 영역에 걸쳐 있을 수는 없습니다.
<br> 마지막으로 각 파일에는 레코드라고 부르는 자식 노드가 있습니다.

- database
- area (테이블 영역)
- file (InnoDB에서의 페이지)
- record

![image](https://github.com/pie2457/Tomato-market/assets/66981851/86e18e14-22a6-4df7-adf0-803857ef67d3)

위의 다이어그램을 예로 들면, 트리의 각 노드들은 개별적으로 잠길 수 있습니다.
2-phase locking 프로토콜에서 S lock과 X lock을 사용할텐데, 한 트랜잭션이 노드를 S lock 혹은 X lock을 사용해 잠글 때 트랜잭션은 암시적으로 해당 노드의 모든 자손을 동일한 잠금 모드로 잠급니다. 예를 들어 트랜잭션 T1이 exclusive mode에서 Fa 대한 명시적인 잠금을 얻으면 해당 파일에 속한 모든 레코드에 대해 exclusive mode로 암묵적인 잠금을 얻습니다. 명시적으로 Fa의 개별 레코드를 잠글 필요는 없습니다.

이제 파일과 레코드의 잠금을 단순화한 상태에서 시스템은 어떻게 루트 노드가 잠길 수 있는지의 여부를 결정할까요?
트리를 순회하는 것은 모든 수준의 락을 검사하여 루트 노드에 대한 잠금이 가능한지의 여부를 결정하는 방법이 될 수 있습니다. 하지만 MGL은 다양한 수준의 락을 효과적으로 관리하고 동시성을 향상시키는 것을 목표로하기 때문에 불필요한 락이나 순회는 성능을 저하시킬 수 있습니다. 더 효과적인 방법은 Intention lock이라 불리는 개념을 도입하는 것입니다.

### Intention lock

Intention lock 은 테이블 레벨의 잠금입니다. Intention lock 은 트랜잭션이 나중에 어떤 잠금을 요청할 것인지를 나타냅니다.
S lock 및 X lock 모드 외에도 multiple granularities를 가진 두 가지 추가 잠금이 존재합니다.

- IS
  - 트랜잭션이 테이블 내의 각 row에 대해 S lock을 잡을 의도가 있음을 나타냅니다.
  - 이 모드는 명시적으로 트리의 낮은 수준에서의 락을 설정하는데 사용됩니다. 그러나 오직 S lock만을 허용합니다. 다른 트랜잭션이 해당 트리 또는 노드에 S lock을 설정하려고 할 때 충돌을 방지하기 위해 사용됩니다.
- IX
  - 트랜잭션이 테이블 내의 각 row에 대해 X lock을 잡을 의도가 있음을 나타냅니다.
  - 이 모드는 명시적으로 트리의 낮은 수준에서의 락을 설정하는 데 사용됩니다. 이 락은 S lock 혹은 X lock이 가능합니다. 다른 트랜잭션이 해당 트리 또는 노드에 X lock 또는 S lock을 설정하려고 할 때 충돌을 방지하기 위해 사용됩니다.

예를 들어, `SELECT ... FOR SHARE`는 IS lock을 설정하고 `SELECT ... FOR UPDATE`는 IX lock을 설정합니다.
Intention locking protocol은 다음 단계를 따릅니다.

- 트랜잭션이 테이블 내의 row에 대해 S lock을 획득하고자 할 때, 반드시 IS lock 혹은 더 강한 락을 가지고 있어야 합니다.
- 트랜잭션이 테이블 내의 row에 대해 X lock을 획득하고자 할 때, 반드시 IX lock을 가지고 있어야 합니다.

테이블 레벨의 잠금 호환성은 아래 표와 같습니다.

|     | X        | IX         | S          | IS         |
| --- | -------- | ---------- | ---------- | ---------- |
| X   | Conflict | Conflict   | Conflict   | Conflict   |
| IX  | Conflict | Compatible | Conflict   | Compatible |
| S   | Conflict | Conflict   | Compatible | Compatible |
| IS  | Conflict | Compatible | Compatible | Compatible |

트랜잭션이 요청하는 잠금이 기존에 있던 잠금과 호환이 가능하다면 해당 요청은 승인됩니다. 하지만 기존에 있던 락과 호환되지 않는다면 승인되지 않고 기존의 호환되지 않는 락이 해제될 때까지 대기합니다. 왜냐하면 데드락의 원인이 되거나 에러를 일으킬 수 있기 때문입니다.

Intention lock 은 `LOCK TABLES … WRITE`와 같은 전체 테이블에 대한 잠금을 요청하는 구문을 제외하고 어떠한 것도 블록하지 않습니다. Intention lock 의 주된 목적은 트랜잭션이 현재 잠금을 획득하고 있거나, 획득할 것이다는 것을 보여주기 위한 것 입니다.

## record lock

레코드 자체만을 잠그는 것을 레코드 락이라고 합니다.
중요한 차이점은 InnoDB에서는 레코드 자체를 잠그는 것이 아닌, 인덱스의 레코드를 잠근다는 것입니다.
인덱스가 하나도 존재하지 않아도 내부적으로 자동 생성된 클러스티드 인덱스를 이용해 잠금을 설정합니다.

## gap lock

갭 락은 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미합니다. 즉, 갭 락의 역할은 레코드 간격 사이에 INSERT 되는 것을 제어하는 것입니다.

## next key lock

레코드 락과 갭 락을 합쳐 놓은 형태의 락을 넥스트 키 락이라 합니다.

InnoDB 테이블의 인덱스를 검색하거나 스캔할 때, 탐색한 인덱스 레코드에 대해 S lock 혹은 X lock 을 설정하는 방식으로 row level locking을 수행합니다. 넥스트 키 락은 해당 인덱스 레코드 앞의 `간격(gap)`에도 영향을 미칩니다.

만약 어떤 트랜잭션이 S 혹은 X lock을 레코드 R에 대해 걸고 있다면, 다른 트랜잭션은 새로운 인덱스 레코드 R 앞에 있는 간격(gap)에 새로운 인덱스 레코드를 삽입할 수 없습니다.

인덱스가 10, 11, 13, 20 을 포함하고 있다고 할 때, 존재할 수 있는 넥스트 키 락 은 다음 구간들을 포함합니다. 둥근 괄호는 구간의 끝지점을 포함하지 않는 것을 나타내고, 각진 괄호는 끝점을 포함하는 것을 의미합니다.

```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

마지막 구간에서 넥스트 키 락은 인덱스의 가장 큰 값을 가진 `supremum` 가상 레코드와 해당 값 사이의 갭을 잠그는 것을 의미합니다.
Supremum은 실제로는 실재하는 인덱스 레코드가 아니며, 인덱스에 실제로 존재하는 어떤 값보다 높은 값을 가지는 특별한 가상 레코드입니다. 따라서 마지막 구간의 다음-키 락은 사실상 가장 큰 인덱스 값의 뒤에 있는 갭만 락하는 것입니다.

InnoDB는 기본적으로 `REPEATABLE READ` 트랜잭션 격리 수준에서 동작합니다. 이 경우 InnoDB는 검색 및 인덱스 스캔에 대해 넥스트 키 락을 사용하며, 이는 `Phantom Rows`를 방지하는 데 사용됩니다.
