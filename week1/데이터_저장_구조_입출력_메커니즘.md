# 데이터 저장 구조와 I/O 메커니즘 (SQL은 왜 느린가?)

## 데이터베이스 저장 구조

DB에서 데이터를 저장하기 위해서는 테이블스페이스를 생성해야합니다. 테이블 스페이스는 세그먼트를 담는 컨테이너로서, 여러 개의 데이터 파일로 구성됩니다.

> 테이블 스페이스 🧐 <br>
> 테이블 스페이스는 데이터를 저장하는데 사용되는 가장 큰 논리적 단위입니다. <br>
> 내부적으로 segment -> extent -> page(block) -> row 형태로 구성됩니다.

![image](https://github.com/masters2023-project-03-second-hand/second-hand-max-be-b/assets/66981851/d4bc0609-1312-40eb-8040-82000b5b9668)

## I/O 란

지금까지 간단하게 데이터베이스 저장구조를 살펴봤습니다. 이번에는 I/O 에 대해 알아보고자 합니다.

I/O는 입출력 연산으로 컴퓨터 파일 시스템에서 데이터를 읽고 쓰는 작업입니다.
친절한 SQL 튜닝 책에서는 I/O를 잠(SLEEP)으로 비유하고 있는데 이는 프로세스가 작업 중 I/O call이 발생하면 OS 혹은 I/O 서브시스템이 I/O 연산을 처리하는 동안 프로세스는 잠을 자기 때문입니다.
프로세스가 잠을 자는 이유는 여러가지가 있습니다.

- Application이 I/O 요청을 위해 System call (SW Interrupt)
- Device가 시킨 일이 끝나면 HW Interrupt 발생 (CPU에게 알려줌)
- 프로세스 스케줄러에 의해
- ...

위와 같이 여러가지 이유가 있지만 I/O가 가장 대표적이며 많은 비중을 차지합니다.
왜 I/O가 발생하면 프로세스는 잠을 자는 거고 여기서 잠은 어떤 의미일까요?

### 프로세스와 생명주기

프로세스는 실행 중인 프로그램을 의미하며 아래와 같은 생명주기를 갖습니다.

![image](https://github.com/masters2023-project-03-second-hand/second-hand-max-be-b/assets/66981851/ddaed1c5-3c0c-4cb7-9da1-7107c545ce61)

잠깐 프로세스의 각 상태를 살펴보면 다음과 같습니다.

- new
  - 프로세스 생성
- ready
  - CPU를 제외한 모든 자원을 할당 받고 CPU를 기다리는 상태
- running
  - CPU를 잡고 instruction 실행 중
- waiting (sleep)
  - CPU를 주어도 당장 instruction을 실행할 수 없는 상태
  - 프로세스 자신이 요청한 이벤트를 만족하지 않아 이를 기다리는 상태 (ex. I/O)
- terminated
  - 수행이 끝난 상태

프로세스는 위의 생명주기를 반복하며 동작합니다. 또한 실행 중(running) 프로세스는 interrupt등의 이유로 수시로 실행 준비 상태로 전환했다가 다시 실행 상태로 전환합니다.
이는 여러 프로세스가 CPU를 사용할 수는 있지만 특정 시점에는 하나의 프로세스만이 CPU를 사용할 수 있기 때문입니다.

즉, interrupt 없이 작업을 수행하던 프로세스도 디스크에서 데이터를 읽어야 할 때는 I/O 요청을 위한 System call을 수행하고 CPU의 제어권을 OS에게 넘겨줍니다. 그러고 나서는 I/O가 완료될 때까지 기다리는 것이죠.

열심히 작업을 해야 할 프로세스가 I/O를 기다린다며 잠을 자버리니 I/O가 많으면 성능이 느려질 수 밖에 없습니다.

### 블록 단위 I/O

I/O 연산이 발생하면 디스크로부터 데이터를 읽고 쓰는 작업을 수행합니다. 이때 단위는 어떻게 될까요? (파일? 세그먼트? 익스텐드? 페이지?)

바로 블록(페이지)이 DBMS가 데이터를 읽고 쓰는 단위입니다. 이는 특정 row만 읽고 싶어도 데이터 입출력단위가 블록이기 때문에 블록을 통째로 읽는 것을 의미합니다.

> 참고로 [MySQL 문서](https://dev.mysql.com/doc/refman/8.0/en/innodb-file-space.html)에 따르면 MySQL 에서는 기본 페이지크기가 16KB라고 합니다.

로우 뿐만 아니라 테이블, 인덱스도 블록 단위로 데이터를 읽고 씁니다.

### 시퀀셜 액세스 VS. 랜덤 액세스

데이터베이스에서 테이블 혹은 인덱스를 읽는 방식은 다음과 같은 두 가지가 있습니다.

- 시퀀셜 액세스
- 랜덤 액세스

#### 시퀀셜 액세스

시퀀셜 액세스는 `논리적` 혹은 `물리적`으로 연결된 순서에 따라 차례대로 블럭(페이지)을 읽는 방식입니다.

인덱스에서 B+Tree 자료구조의 경우 리프 노드는 앞뒤를 가리키는 양방향 연결 리스트 형태로 되어 있습니다. 이때 서로의 주소값을 가리키게 되는데 이 주소값에 따라 앞 혹은 뒤로 순차적으로 스캔하는 방식입니다.

그런데 테이블 블럭(페이지)간에는 서로 논리적인 연결을 가지고 있지 않습니다.
오라클의 경우 세그먼트에 할당된 익스텐트 목록을 헤더에 맵(map)형태로 관리하는데 이 맵은 각 익스텐트의 첫 번째 블럭(페이지) 주소 값을 갖습니다. <br>
그러면 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블럭 뒤에 연속해서 저장된 블럭을 순서대로 읽으면 이것이 `Full Table Scan`이 됩니다.

#### 랜덤 액세스

랜덤 액세스는 논리적, 물리적인 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블럭(페이지)씩 접근하는 방식입니다.

#### MySQL에서의 액세스(I/O)

MySQL에서 시퀀셜 액세스는 물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식입니다.
예를 들어 순차 I/O는 3개의 페이지(3 X 16KB)를 디스크에 기록하기 위해 1번의 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 위해 3번 시스템 콜을 요청합니다.

그래서 여러 번 쓰기 혹은 읽기를 요청하는 랜덤 I/O작업이 작업 부하가 더 크다고 볼 수 있습니다.

![image](https://github.com/codesquad-members-2023/second-hand-max/assets/66981851/3958c43a-133a-4dd9-9f47-b3256fb3fb70)

## DB 버퍼 캐시

SQL을 수행하는 과정에서 매번 데이터 블럭(페이지)을 읽기 위해 I/O가 발생하는 것은 비효율적입니다. 그렇기 때문에 모든 DBMS에 데이터 캐싱 메커니즘이 존재합니다.

이를 위해 데이터를 캐싱하는 `DB 버퍼캐시`가 존재합니다. 디스크에서 I/O call을 통해 읽어들인 데이터 블럭(페이지)를 캐싱해 둠으로써 같은 블럭에 대한 반복적인 I/O call을 줄이는데 목적이 있습니다.

따라서 데이터 블럭(페이지)을 읽을 땐 항상 버퍼캐시부터 탐색합니다. 캐시 히트가 된다면 프로세스가 I/O call로 인해 잠(sleep)에 빠져들지 않으니 성능이 좋아집니다.
물론 캐시 미스가 된다해도 I/O call이 발생해 프로세스가 잠에 들겠지만 이후 동일한 데이터 블럭(페이지)를 읽는 요청부터는 잠을 자지 않아도 됩니다.

> MySQL InooDB 엔진의 경우 InnoDB 버퍼 풀이 존재합니다. 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해둡니다.

## 결론

`SQL은 왜 느린가?`에 대한 답을 위해 지금까지 여러 개념을 살펴봤습니다. 결론적으로 SQL은 디스크 I/O 때문에 느립니다. I/O call로 인해 실행중인 프로세스는 SLEEP 상태로 전환될 것이고 CPU의 제어권은 I/O call을 처리하기 위해 OS로 넘어가기 때문에 열심히 일해야 할 프로세스가 일의 효율을 못내는 것이죠.
